#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Pod::Usage;
use JSON;
use File::Basename;
use POSIX qw(strftime);

# Ajout du chemin des modules PVE
use lib '/usr/share/perl5';

use PVE::Storage::S3::Client;
use PVE::Storage::S3::Config;
use PVE::Storage::S3::Auth;
use PVE::Storage::S3::Metadata;
use PVE::Storage::S3::Utils qw(log_info log_warn log_error format_bytes);

# Variables globales
my $VERSION = '1.0.0';
my $PROGRAM = 'pve-s3-backup';

# Options par défaut
my %options = (
    config_file => '/etc/pve/storage.cfg',
    storage_id => undef,
    source => undef,
    vmid => undef,
    format => 'raw',
    compress => undef,
    notes => undef,
    verbose => 0,
    dry_run => 0,
    help => 0,
    version => 0,
);

# Parse des arguments
GetOptions(
    'config|c=s' => \$options{config_file},
    'storage|s=s' => \$options{storage_id},
    'source=s' => \$options{source},
    'vmid=i' => \$options{vmid},
    'format=s' => \$options{format},
    'compress=s' => \$options{compress},
    'notes=s' => \$options{notes},
    'verbose|v' => \$options{verbose},
    'dry-run|n' => \$options{dry_run},
    'help|h' => \$options{help},
    'version|V' => \$options{version},
) or pod2usage(2);

# Affichage de l'aide
if ($options{help}) {
    pod2usage(-verbose => 2);
    exit 0;
}

# Affichage de la version
if ($options{version}) {
    print "$PROGRAM version $VERSION\n";
    exit 0;
}

# Validation des arguments
if (!$options{storage_id}) {
    die "Error: Storage ID is required (use --storage)\n";
}

if (!$options{source}) {
    die "Error: Source file is required (use --source)\n";
}

# Fonction principale
sub main {
    eval {
        # Chargement de la configuration du storage
        my $storage_config = load_storage_config($options{storage_id});
        
        # Création du client S3
        my $s3_client = create_s3_client($storage_config);
        
        # Test de connectivité
        log_info("Testing S3 connection...") if $options{verbose};
        $s3_client->test_connection();
        
        # Préparation des métadonnées
        my $metadata = prepare_backup_metadata();
        
        # Génération du nom de destination
        my $dest_key = generate_backup_name($options{source});
        
        if ($options{dry_run}) {
            print "DRY RUN: Would backup '$options{source}' to 's3://$storage_config->{bucket}/$dest_key'\n";
            print "Metadata: " . $metadata->to_log_string() . "\n";
            return;
        }
        
        # Exécution du backup
        log_info("Starting backup: $options{source} -> s3://$storage_config->{bucket}/$dest_key");
        
        my $result = $s3_client->upload_file(
            $options{source},
            $storage_config->{bucket},
            $dest_key,
            {
                metadata => $metadata->get_all(),
                content_type => 'application/octet-stream',
            }
        );
        
        # Affichage des résultats
        my $file_size = -s $options{source};
        print "Backup completed successfully!\n";
        print "  Source: $options{source}\n";
        print "  Destination: s3://$storage_config->{bucket}/$dest_key\n";
        print "  Size: " . format_bytes($file_size) . "\n";
        print "  Duration: " . sprintf("%.2f", $result->{duration}) . "s\n";
        print "  Throughput: " . sprintf("%.2f", $result->{throughput}) . " MB/s\n" if $result->{throughput};
        print "  Operation ID: $result->{operation_id}\n" if $options{verbose};
        
    };
    if ($@) {
        log_error("Backup failed: $@");
        die "Backup failed: $@\n";
    }
}

# Chargement de la configuration du storage
sub load_storage_config {
    my ($storage_id) = @_;
    
    # Simulation de chargement - dans la vraie vie, cela chargerait depuis /etc/pve/storage.cfg
    my $config = {
        type => 's3',
        endpoint => $ENV{S3_ENDPOINT} || 's3.amazonaws.com',
        bucket => $ENV{S3_BUCKET} || die "S3_BUCKET environment variable required\n",
        region => $ENV{S3_REGION} || 'us-east-1',
        access_key => $ENV{S3_ACCESS_KEY} || die "S3_ACCESS_KEY environment variable required\n",
        secret_key => $ENV{S3_SECRET_KEY} || die "S3_SECRET_KEY environment variable required\n",
        prefix => $ENV{S3_PREFIX} || 'proxmox/',
    };
    
    log_info("Loaded storage configuration for '$storage_id'") if $options{verbose};
    
    return $config;
}

# Création du client S3
sub create_s3_client {
    my ($storage_config) = @_;
    
    my $config = PVE::Storage::S3::Config->new($storage_config);
    my $auth = PVE::Storage::S3::Auth->new($storage_config);
    
    return PVE::Storage::S3::Client->new($config, $auth);
}

# Préparation des métadonnées de backup
sub prepare_backup_metadata {
    my $metadata = PVE::Storage::S3::Metadata->new();
    
    # Détection automatique du type de backup depuis le nom de fichier
    my $basename = basename($options{source});
    my ($backup_type, $vmid_detected, $format_detected);
    
    if ($basename =~ /vzdump-(\w+)-(\d+)/) {
        $backup_type = $1;
        $vmid_detected = $2;
    }
    
    # Paramètres de backup
    my $backup_params = {
        type => $backup_type || 'unknown',
        vmid => $options{vmid} || $vmid_detected,
        format => $options{format},
        backup_time => time(),
        original_size => -s $options{source},
        hostname => `hostname` || 'unknown',
        pve_version => get_pve_version(),
    };
    
    # Ajout de la compression si spécifiée
    if ($options{compress}) {
        $backup_params->{compression} = $options{compress};
    }
    
    # Ajout des notes si spécifiées
    if ($options{notes}) {
        $metadata->set_custom_metadata('notes', $options{notes});
    }
    
    $metadata->set_backup_metadata($backup_params);
    $metadata->set_timestamps();
    
    return $metadata;
}

# Génération du nom de backup sur S3
sub generate_backup_name {
    my ($source_file) = @_;
    
    my $basename = basename($source_file);
    my $timestamp = strftime('%Y%m%d_%H%M%S', localtime());
    
    # Si c'est déjà un nom de backup Proxmox, on le garde
    if ($basename =~ /^vzdump-/) {
        return "backup/$basename";
    }
    
    # Sinon, on génère un nom standard
    my $vmid = $options{vmid} || 'unknown';
    my $format = $options{format} || 'raw';
    
    return "backup/vzdump-qemu-$vmid-$timestamp.$format";
}

# Récupération de la version PVE
sub get_pve_version {
    if (open my $fh, '<', '/usr/bin/pveversion') {
        my $output = `pveversion --verbose 2>/dev/null | head -1`;
        chomp $output;
        return $output || 'unknown';
    }
    return 'unknown';
}

# Point d'entrée principal
main();

__END__

=head1 NAME

pve-s3-backup - Backup files to S3 storage for Proxmox VE

=head1 SYNOPSIS

pve-s3-backup [OPTIONS]

=head1 DESCRIPTION

This script provides a command-line interface for backing up files to S3-compatible
storage systems from Proxmox VE. It handles large file uploads efficiently using
multipart uploads and provides progress tracking.

=head1 OPTIONS

=over 4

=item B<--storage, -s> I<STORAGE_ID>

ID of the S3 storage configuration to use (required).

=item B<--source> I<FILE>

Path to the source file to backup (required).

=item B<--vmid> I<VMID>

Virtual machine ID for the backup (optional, auto-detected from filename).

=item B<--format> I<FORMAT>

Backup format: raw, qcow2, tar, vma (default: raw).

=item B<--compress> I<COMPRESSION>

Compression algorithm: gzip, lzop, zstd (optional).

=item B<--notes> I<TEXT>

Additional notes to store with the backup (optional).

=item B<--config, -c> I<FILE>

Path to Proxmox storage configuration file (default: /etc/pve/storage.cfg).

=item B<--verbose, -v>

Enable verbose output.

=item B<--dry-run, -n>

Show what would be done without actually performing the backup.

=item B<--help, -h>

Show this help message.

=item B<--version, -V>

Show version information.

=back

=head1 ENVIRONMENT

The following environment variables can be used for S3 configuration:

=over 4

=item B<S3_ENDPOINT>

S3 endpoint URL

=item B<S3_BUCKET>

S3 bucket name

=item B<S3_REGION>

S3 region (default: us-east-1)

=item B<S3_ACCESS_KEY>

S3 access key ID

=item B<S3_SECRET_KEY>

S3 secret access key

=item B<S3_PREFIX>

Object key prefix (default: proxmox/)

=back

=head1 EXAMPLES

Backup a VM disk to S3:

  pve-s3-backup --storage s3-storage --source /var/lib/vz/images/100/vm-100-disk-0.qcow2 --vmid 100

Backup with compression and notes:

  pve-s3-backup --storage s3-storage --source backup.tar --compress gzip --notes "Weekly backup"

Dry run to see what would be uploaded:

  pve-s3-backup --storage s3-storage --source file.raw --dry-run

=head1 EXIT STATUS

=over 4

=item 0

Success

=item 1

General error

=item 2

Invalid command line arguments

=back

=head1 SEE ALSO

pve-s3-restore(1), pve-s3-maintenance(1)

=head1 AUTHOR

Proxmox S3 Plugin Team

=cut